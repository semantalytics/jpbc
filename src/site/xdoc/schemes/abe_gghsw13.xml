<!DOCTYPE document PUBLIC
        "-//Apache Software Foundation//DTD XDOC 1.0//EN"
        "http://maven.apache.org/dtd/xdoc_1_0.dtd">
<document>
    <properties>
        <title>Java Pairing-Based Cryptography Library : Schemes - Functional Encryption for Regular Languages</title>
        <author email="decaro@dia.unisa.it">Angelo De Caro</author>
    </properties>

    <body>
        <section name="Functional Encryption for Regular Languages">
            <subsection name="Authors">
                Sanjam Garg and Craig Gentry and Shai Halevi and Amit Sahai and Brent Waters
            </subsection>

            <subsection name="Abstract">
                In this work, we provide the first construction of Attribute-Based Encryption (ABE) for
                general circuits. Our construction is based on the existence of multilinear maps. We prove selective
                security of our scheme in the standard model under the natural multilinear generalization of
                the BDDH assumption. Our scheme achieves both Key-Policy and Ciphertext-Policy variants
                of ABE.
                Our scheme and its proof of security directly translate to the recent multilinear map
                framework of Garg, Gentry, and Halevi.
                This paper subsumes the manuscript of Sahai and Waters [SW12].
            </subsection>

            <subsection name="URL">
                <a href="http://eprint.iacr.org/2013/128.pdf">
                    http://eprint.iacr.org/2013/128.pdf
                </a>
            </subsection>
        </section>

        <section name="Usage of the scheme">
<pre>

<a name="l1"><span class="ln">1    </span></a><span class="s0">package </span><span class="s1">it.unisa.dia.gas.crypto.jpbc.fe.abe.gghsw13;
<a name="l2"><span class="ln">2    </span></a>
<a name="l3"><span class="ln">3    </span></a></span><span class="s0">import </span><span class="s1">it.unisa.dia.gas.crypto.engines.kem.KeyEncapsulationMechanism;
<a name="l4"><span class="ln">4    </span></a></span><span class="s0">import </span><span class="s1">it.unisa.dia.gas.crypto.jpbc.fe.abe.gghsw13.engines.DefaultCircuit;
<a name="l5"><span class="ln">5    </span></a></span><span class="s0">import </span><span class="s1">it.unisa.dia.gas.crypto.jpbc.fe.abe.gghsw13.engines.GGHSW13KemEngine;
<a name="l6"><span class="ln">6    </span></a></span><span class="s0">import </span><span class="s1">it.unisa.dia.gas.crypto.jpbc.fe.abe.gghsw13.generators.GGHSW13KeyPairGenerator;
<a name="l7"><span class="ln">7    </span></a></span><span class="s0">import </span><span class="s1">it.unisa.dia.gas.crypto.jpbc.fe.abe.gghsw13.generators.GGHSW13ParametersGenerator;
<a name="l8"><span class="ln">8    </span></a></span><span class="s0">import </span><span class="s1">it.unisa.dia.gas.crypto.jpbc.fe.abe.gghsw13.generators.GGHSW13SecretKeyGenerator;
<a name="l9"><span class="ln">9    </span></a></span><span class="s0">import </span><span class="s1">it.unisa.dia.gas.crypto.jpbc.fe.abe.gghsw13.params.*;
<a name="l10"><span class="ln">10   </span></a></span><span class="s0">import </span><span class="s1">it.unisa.dia.gas.plaf.jpbc.mm.clt13.parameters.CTL13MMInstanceParameters;
<a name="l11"><span class="ln">11   </span></a></span><span class="s0">import </span><span class="s1">org.bouncycastle.crypto.AsymmetricCipherKeyPair;
<a name="l12"><span class="ln">12   </span></a></span><span class="s0">import </span><span class="s1">org.bouncycastle.crypto.CipherParameters;
<a name="l13"><span class="ln">13   </span></a></span><span class="s0">import </span><span class="s1">org.bouncycastle.crypto.InvalidCipherTextException;
<a name="l14"><span class="ln">14   </span></a></span><span class="s0">import </span><span class="s1">org.junit.Test;
<a name="l15"><span class="ln">15   </span></a></span><span class="s0">import </span><span class="s1">org.junit.runner.RunWith;
<a name="l16"><span class="ln">16   </span></a></span><span class="s0">import </span><span class="s1">org.junit.runners.Parameterized;
<a name="l17"><span class="ln">17   </span></a>
<a name="l18"><span class="ln">18   </span></a></span><span class="s0">import </span><span class="s1">java.security.SecureRandom;
<a name="l19"><span class="ln">19   </span></a></span><span class="s0">import </span><span class="s1">java.util.Arrays;
<a name="l20"><span class="ln">20   </span></a></span><span class="s0">import </span><span class="s1">java.util.Collection;
<a name="l21"><span class="ln">21   </span></a>
<a name="l22"><span class="ln">22   </span></a></span><span class="s0">import static </span><span class="s1">it.unisa.dia.gas.crypto.jpbc.fe.abe.gghsw13.engines.DefaultCircuit.DefaultGate;
<a name="l23"><span class="ln">23   </span></a></span><span class="s0">import static </span><span class="s1">it.unisa.dia.gas.crypto.jpbc.fe.abe.gghsw13.params.Circuit.Gate.Type.*;
<a name="l24"><span class="ln">24   </span></a></span><span class="s0">import static </span><span class="s1">org.junit.Assert.*;
<a name="l25"><span class="ln">25   </span></a>
<a name="l26"><span class="ln">26   </span></a></span><span class="s2">/**
<a name="l27"><span class="ln">27   </span></a> * </span><span class="s3">@author </span><span class="s2">Angelo De Caro
<a name="l28"><span class="ln">28   </span></a> */</span><span class="s1">
<a name="l29"><span class="ln">29   </span></a>@RunWith(value = Parameterized.</span><span class="s0">class</span><span class="s1">)
<a name="l30"><span class="ln">30   </span></a></span><span class="s0">public class </span><span class="s1">GGHSW13KEMEngineTest {
<a name="l31"><span class="ln">31   </span></a>
<a name="l32"><span class="ln">32   </span></a>    </span><span class="s0">static </span><span class="s1">SecureRandom random;
<a name="l33"><span class="ln">33   </span></a>    </span><span class="s0">static </span><span class="s1">{
<a name="l34"><span class="ln">34   </span></a>        random = </span><span class="s0">new </span><span class="s1">SecureRandom();
<a name="l35"><span class="ln">35   </span></a>    }
<a name="l36"><span class="ln">36   </span></a>
<a name="l37"><span class="ln">37   </span></a>    @Parameterized.Parameters
<a name="l38"><span class="ln">38   </span></a>    </span><span class="s0">public static </span><span class="s1">Collection parameters() {
<a name="l39"><span class="ln">39   </span></a>        Object[][] data = {
<a name="l40"><span class="ln">40   </span></a>                {CTL13MMInstanceParameters.TOY}
<a name="l41"><span class="ln">41   </span></a>        };
<a name="l42"><span class="ln">42   </span></a>
<a name="l43"><span class="ln">43   </span></a>        </span><span class="s0">return </span><span class="s1">Arrays.asList(data);
<a name="l44"><span class="ln">44   </span></a>    }
<a name="l45"><span class="ln">45   </span></a>
<a name="l46"><span class="ln">46   </span></a>
<a name="l47"><span class="ln">47   </span></a>    </span><span class="s0">protected </span><span class="s1">CTL13MMInstanceParameters instanceParameters;
<a name="l48"><span class="ln">48   </span></a>
<a name="l49"><span class="ln">49   </span></a>
<a name="l50"><span class="ln">50   </span></a>    </span><span class="s0">public </span><span class="s1">GGHSW13KEMEngineTest(CTL13MMInstanceParameters instanceParameters) {
<a name="l51"><span class="ln">51   </span></a>        </span><span class="s0">this</span><span class="s1">.instanceParameters = instanceParameters;
<a name="l52"><span class="ln">52   </span></a>    }
<a name="l53"><span class="ln">53   </span></a>
<a name="l54"><span class="ln">54   </span></a>
<a name="l55"><span class="ln">55   </span></a>    @Test
<a name="l56"><span class="ln">56   </span></a>    </span><span class="s0">public void </span><span class="s1">testGGHSW13KEMEngine() {
<a name="l57"><span class="ln">57   </span></a>        SecureRandom random = </span><span class="s0">new </span><span class="s1">SecureRandom();
<a name="l58"><span class="ln">58   </span></a>        </span><span class="s0">int </span><span class="s1">n = </span><span class="s4">4</span><span class="s1">;
<a name="l59"><span class="ln">59   </span></a>        </span><span class="s0">int </span><span class="s1">q = </span><span class="s4">3</span><span class="s1">;
<a name="l60"><span class="ln">60   </span></a>        Circuit circuit = </span><span class="s0">new </span><span class="s1">DefaultCircuit(n, q, </span><span class="s4">3</span><span class="s1">, </span><span class="s0">new </span><span class="s1">DefaultGate[]{
<a name="l61"><span class="ln">61   </span></a>                </span><span class="s0">new </span><span class="s1">DefaultGate(INPUT, </span><span class="s4">0</span><span class="s1">, </span><span class="s4">1</span><span class="s1">, </span><span class="s0">null</span><span class="s1">),
<a name="l62"><span class="ln">62   </span></a>                </span><span class="s0">new </span><span class="s1">DefaultGate(INPUT, </span><span class="s4">1</span><span class="s1">, </span><span class="s4">1</span><span class="s1">, </span><span class="s0">null</span><span class="s1">),
<a name="l63"><span class="ln">63   </span></a>                </span><span class="s0">new </span><span class="s1">DefaultGate(INPUT, </span><span class="s4">2</span><span class="s1">, </span><span class="s4">1</span><span class="s1">, </span><span class="s0">null</span><span class="s1">),
<a name="l64"><span class="ln">64   </span></a>                </span><span class="s0">new </span><span class="s1">DefaultGate(INPUT, </span><span class="s4">3</span><span class="s1">, </span><span class="s4">1</span><span class="s1">, </span><span class="s0">null</span><span class="s1">),
<a name="l65"><span class="ln">65   </span></a>
<a name="l66"><span class="ln">66   </span></a>                </span><span class="s0">new </span><span class="s1">DefaultGate(AND, </span><span class="s4">4</span><span class="s1">, </span><span class="s4">2</span><span class="s1">, </span><span class="s0">new int</span><span class="s1">[]{</span><span class="s4">0</span><span class="s1">, </span><span class="s4">1</span><span class="s1">}),
<a name="l67"><span class="ln">67   </span></a>                </span><span class="s0">new </span><span class="s1">DefaultGate(OR, </span><span class="s4">5</span><span class="s1">, </span><span class="s4">2</span><span class="s1">, </span><span class="s0">new int</span><span class="s1">[]{</span><span class="s4">2</span><span class="s1">, </span><span class="s4">3</span><span class="s1">}),
<a name="l68"><span class="ln">68   </span></a>
<a name="l69"><span class="ln">69   </span></a>                </span><span class="s0">new </span><span class="s1">DefaultGate(AND, </span><span class="s4">6</span><span class="s1">, </span><span class="s4">3</span><span class="s1">, </span><span class="s0">new int</span><span class="s1">[]{</span><span class="s4">4</span><span class="s1">, </span><span class="s4">5</span><span class="s1">}),
<a name="l70"><span class="ln">70   </span></a>        });
<a name="l71"><span class="ln">71   </span></a>
<a name="l72"><span class="ln">72   </span></a>        AsymmetricCipherKeyPair keyPair = setup(createParameters(random, n));
<a name="l73"><span class="ln">73   </span></a>        CipherParameters secretKey = keyGen(keyPair.getPublic(), keyPair.getPrivate(), circuit);
<a name="l74"><span class="ln">74   </span></a>
<a name="l75"><span class="ln">75   </span></a>        String assignment = </span><span class="s5">&quot;1101&quot;</span><span class="s1">;
<a name="l76"><span class="ln">76   </span></a>        </span><span class="s0">byte</span><span class="s1">[][] ct = encaps(keyPair.getPublic(), assignment);
<a name="l77"><span class="ln">77   </span></a>        assertEquals(</span><span class="s0">true</span><span class="s1">, Arrays.equals(ct[</span><span class="s4">0</span><span class="s1">], decaps(secretKey, ct[</span><span class="s4">1</span><span class="s1">])));
<a name="l78"><span class="ln">78   </span></a>
<a name="l79"><span class="ln">79   </span></a>        assignment = </span><span class="s5">&quot;1001&quot;</span><span class="s1">;
<a name="l80"><span class="ln">80   </span></a>        ct = encaps(keyPair.getPublic(), assignment);
<a name="l81"><span class="ln">81   </span></a>        assertEquals(</span><span class="s0">false</span><span class="s1">, Arrays.equals(ct[</span><span class="s4">0</span><span class="s1">], decaps(secretKey, ct[</span><span class="s4">1</span><span class="s1">])));
<a name="l82"><span class="ln">82   </span></a>    }
<a name="l83"><span class="ln">83   </span></a>
<a name="l84"><span class="ln">84   </span></a>
<a name="l85"><span class="ln">85   </span></a>    </span><span class="s0">protected </span><span class="s1">GGHSW13Parameters createParameters(SecureRandom random, </span><span class="s0">int </span><span class="s1">n) {
<a name="l86"><span class="ln">86   </span></a>        </span><span class="s0">return new </span><span class="s1">GGHSW13ParametersGenerator().init(random, instanceParameters, n).generateParameters();
<a name="l87"><span class="ln">87   </span></a>    }
<a name="l88"><span class="ln">88   </span></a>
<a name="l89"><span class="ln">89   </span></a>    </span><span class="s0">protected </span><span class="s1">AsymmetricCipherKeyPair setup(GGHSW13Parameters parameters) {
<a name="l90"><span class="ln">90   </span></a>        GGHSW13KeyPairGenerator setup = </span><span class="s0">new </span><span class="s1">GGHSW13KeyPairGenerator();
<a name="l91"><span class="ln">91   </span></a>        setup.init(</span><span class="s0">new </span><span class="s1">GGHSW13KeyPairGenerationParameters(
<a name="l92"><span class="ln">92   </span></a>                </span><span class="s0">new </span><span class="s1">SecureRandom(),
<a name="l93"><span class="ln">93   </span></a>                parameters
<a name="l94"><span class="ln">94   </span></a>        ));
<a name="l95"><span class="ln">95   </span></a>
<a name="l96"><span class="ln">96   </span></a>        </span><span class="s0">return </span><span class="s1">setup.generateKeyPair();
<a name="l97"><span class="ln">97   </span></a>    }
<a name="l98"><span class="ln">98   </span></a>
<a name="l99"><span class="ln">99   </span></a>    </span><span class="s0">protected byte</span><span class="s1">[][] encaps(CipherParameters publicKey, String w) {
<a name="l100"><span class="ln">100  </span></a>        </span><span class="s0">try </span><span class="s1">{
<a name="l101"><span class="ln">101  </span></a>            KeyEncapsulationMechanism kem = </span><span class="s0">new </span><span class="s1">GGHSW13KemEngine();
<a name="l102"><span class="ln">102  </span></a>            kem.init(</span><span class="s0">true</span><span class="s1">, </span><span class="s0">new </span><span class="s1">GGHSW13EncryptionParameters((GGHSW13PublicKeyParameters) publicKey, w));
<a name="l103"><span class="ln">103  </span></a>
<a name="l104"><span class="ln">104  </span></a>            </span><span class="s0">byte</span><span class="s1">[] ciphertext = kem.processBlock(</span><span class="s0">new byte</span><span class="s1">[</span><span class="s4">0</span><span class="s1">], </span><span class="s4">0</span><span class="s1">, </span><span class="s4">0</span><span class="s1">);
<a name="l105"><span class="ln">105  </span></a>
<a name="l106"><span class="ln">106  </span></a>            assertNotNull(ciphertext);
<a name="l107"><span class="ln">107  </span></a>            assertNotSame(</span><span class="s4">0</span><span class="s1">, ciphertext.length);
<a name="l108"><span class="ln">108  </span></a>
<a name="l109"><span class="ln">109  </span></a>            </span><span class="s0">byte</span><span class="s1">[] key = Arrays.copyOfRange(ciphertext, </span><span class="s4">0</span><span class="s1">, kem.getKeyBlockSize());
<a name="l110"><span class="ln">110  </span></a>            </span><span class="s0">byte</span><span class="s1">[] ct = Arrays.copyOfRange(ciphertext, kem.getKeyBlockSize(), ciphertext.length);
<a name="l111"><span class="ln">111  </span></a>
<a name="l112"><span class="ln">112  </span></a>            </span><span class="s0">return new byte</span><span class="s1">[][]{key, ct};
<a name="l113"><span class="ln">113  </span></a>        } </span><span class="s0">catch </span><span class="s1">(InvalidCipherTextException e) {
<a name="l114"><span class="ln">114  </span></a>            e.printStackTrace();
<a name="l115"><span class="ln">115  </span></a>            fail(e.getMessage());
<a name="l116"><span class="ln">116  </span></a>        }
<a name="l117"><span class="ln">117  </span></a>        </span><span class="s0">return null</span><span class="s1">;
<a name="l118"><span class="ln">118  </span></a>    }
<a name="l119"><span class="ln">119  </span></a>
<a name="l120"><span class="ln">120  </span></a>    </span><span class="s0">protected </span><span class="s1">CipherParameters keyGen(CipherParameters publicKey, CipherParameters masterSecretKey, Circuit circuit) {
<a name="l121"><span class="ln">121  </span></a>        </span><span class="s2">// Init the Generator</span><span class="s1">
<a name="l122"><span class="ln">122  </span></a>        GGHSW13SecretKeyGenerator keyGen = </span><span class="s0">new </span><span class="s1">GGHSW13SecretKeyGenerator();
<a name="l123"><span class="ln">123  </span></a>        keyGen.init(</span><span class="s0">new </span><span class="s1">GGHSW13SecretKeyGenerationParameters(
<a name="l124"><span class="ln">124  </span></a>                (GGHSW13PublicKeyParameters) publicKey,
<a name="l125"><span class="ln">125  </span></a>                (GGHSW13MasterSecretKeyParameters) masterSecretKey,
<a name="l126"><span class="ln">126  </span></a>                circuit
<a name="l127"><span class="ln">127  </span></a>        ));
<a name="l128"><span class="ln">128  </span></a>
<a name="l129"><span class="ln">129  </span></a>        </span><span class="s2">// Generate the key</span><span class="s1">
<a name="l130"><span class="ln">130  </span></a>        </span><span class="s0">return </span><span class="s1">keyGen.generateKey();
<a name="l131"><span class="ln">131  </span></a>    }
<a name="l132"><span class="ln">132  </span></a>
<a name="l133"><span class="ln">133  </span></a>    </span><span class="s0">protected byte</span><span class="s1">[] decaps(CipherParameters secretKey, </span><span class="s0">byte</span><span class="s1">[] ciphertext) {
<a name="l134"><span class="ln">134  </span></a>        </span><span class="s0">try </span><span class="s1">{
<a name="l135"><span class="ln">135  </span></a>            KeyEncapsulationMechanism kem = </span><span class="s0">new </span><span class="s1">GGHSW13KemEngine();
<a name="l136"><span class="ln">136  </span></a>
<a name="l137"><span class="ln">137  </span></a>            kem.init(</span><span class="s0">false</span><span class="s1">, secretKey);
<a name="l138"><span class="ln">138  </span></a>            </span><span class="s0">byte</span><span class="s1">[] key = kem.processBlock(ciphertext, </span><span class="s4">0</span><span class="s1">, ciphertext.length);
<a name="l139"><span class="ln">139  </span></a>
<a name="l140"><span class="ln">140  </span></a>            assertNotNull(key);
<a name="l141"><span class="ln">141  </span></a>            assertNotSame(</span><span class="s4">0</span><span class="s1">, key.length);
<a name="l142"><span class="ln">142  </span></a>
<a name="l143"><span class="ln">143  </span></a>            </span><span class="s0">return </span><span class="s1">key;
<a name="l144"><span class="ln">144  </span></a>        } </span><span class="s0">catch </span><span class="s1">(InvalidCipherTextException e) {
<a name="l145"><span class="ln">145  </span></a>            e.printStackTrace();
<a name="l146"><span class="ln">146  </span></a>            fail(e.getMessage());
<a name="l147"><span class="ln">147  </span></a>        }
<a name="l148"><span class="ln">148  </span></a>
<a name="l149"><span class="ln">149  </span></a>        </span><span class="s0">return null</span><span class="s1">;
<a name="l150"><span class="ln">150  </span></a>    }
<a name="l151"><span class="ln">151  </span></a>
<a name="l152"><span class="ln">152  </span></a>}</span></pre>
        </section>

    </body>
</document>
