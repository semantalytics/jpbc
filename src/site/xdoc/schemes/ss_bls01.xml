<!DOCTYPE document PUBLIC
        "-//Apache Software Foundation//DTD XDOC 1.0//EN"
        "http://maven.apache.org/dtd/xdoc_1_0.dtd">
<document>
    <properties>
        <title>Java Pairing-Based Cryptography Library : Schemes - Short signatures from the Weil pairing</title>
        <author email="decaro@dia.unisa.it">Angelo De Caro</author>
    </properties>

    <body>
        <section name="Short signatures from the Weil pairing">
            <subsection name="Authors">
                D. Boneh, B. Lynn, and H. Shacham.
            </subsection>

            <subsection name="Abstract">
                <a href="http://en.wikipedia.org/wiki/BLS_(cryptography)">[wikipedia]</a>
                In cryptography, the Boneh-Lynn-Shacham signature scheme allows a user to verify that a
                signer is authentic. The scheme uses a pairing function for verification and
                signatures are group elements in some elliptic curve.
                Working in an elliptic curve provides defense against index calculus attacks
                against allowing shorter signatures than FDH signatures. Signatures are often
                referred to as short signatures, BLS short signatures, or simply BLS signatures.
                The signature scheme is provably secure (that is, the scheme is existentially unforgeable
                under adaptive chosen-message attacks) assuming both the existence of random oracles and the
                intractability of the computational Diffie-Hellman problem.
            </subsection>

            <p>
                In this page we will see how to:
            </p>
            <ol>
                <li>
                    implement
                    <font style="font-weight: bold;color:red"><a href="#bls">BLS</a></font>
                    using jPBC.
                </li>
                <li>
                    use
                    <font style="font-weight: bold;color:red"><a href="#blsBCF">BLS</a></font>
                    in the context of the Bouncy Castle framework.
                </li>
            </ol>

        </section>

        <a name="bls"/>
        <section name="BLS">

            <subsection name="Key Generation">
                <p>
                    The key generation algorithm selects a random integer
                    <span class="texhtml">
                        <i>x</i>
                    </span>
                    in
                    <span class="emphasis">
                        <em>Zr</em>
                    </span>.

                </p>

                <ol>
                    <li>
                        The
                        <font style="font-weight: bold;color:red">Private Key</font>
                        is
                        <span class="texhtml">
                            <i>x</i>;
                        </span>
                    </li>
                    <li>
                        the
                        <font style="font-weight: bold;color:red">Public Key</font>
                        is
                        <span class="texhtml">
                            <i>g</i>
                            <sup>
                                <i>x</i>
                            </sup>.
                        </span>
                    </li>
                </ol>

                <p>
                    Let's see how to do that using jPBC:
                </p>

                <source xml:space="preserve">
import it.unisa.dia.gas.plaf.jpbc.pairing.PairingFactory;

<font style="font-weight: bold;color:green">// Init Pairings</font>

CurveParams curveParams = new CurveParams().load("curve.properties");
Pairing pairing = PairingFactory.getPairing(curveParams);

<font style="font-weight: bold;color:green">// Generate system parameters</font>

Element g = pairing.getG1().newRandomElement().getImmutable();

<font style="font-weight: bold;color:green">// Generate the secret key</font>

Element x = pairing.getZr().newRandomElement();

<font style="font-weight: bold;color:green">// Generate the corresponding public key</font>

Element pk = g.powZn(x);
                </source>
            </subsection>

            <subsection name="Signing">
                <p>
                    Given the private key
                    <span class="texhtml">
                        <i>x</i>
                    </span>, and some message
                    <span class="texhtml">
                        <i>m</i>
                    </span>, first we compute the hash of the message and then we map the hash to some element
                    <i>h</i> of  G1. We output the signature
                    <span class="texhtml">sig =
                        <i>h</i>
                        <sup>
                            <i>x</i>
                        </sup>
                    </span>.
                </p>

                <p>
                    Using jPBC we have:
                </p>
                <source xml:space="preserve">
<font style="font-weight: bold;color:green">// Map the hash of the message m to some element of G1</font>

byte[] hash = ... // Generate an hash from m (48-bit hash)
Element h = pairing.getG1().newElement().setFromHash(hash, 0, hash.length);

<font style="font-weight: bold;color:green">// Generate the signature</font>

Element sig = h.powZn(x);
</source>
            </subsection>

            <subsection name="Verification">
                <p>
                    Given a signature
                    <span class="texhtml">sig</span>
                    and a public key
                    <span class="texhtml">
                        <i>g</i>
                        <sup>
                            <i>x</i>
                        </sup>
                    </span>, we verify that
                    <span class="texhtml"><i>e</i>(sig, <i>g</i>) =<i>e</i>(h,
                        <i>g</i>
                        <sup>
                            <i>x</i>
                        </sup>
                        )
                    </span>.
                </p>

                <p>
                    Again using jPBC::
                </p>
                <source xml:space="preserve">

<font style="font-weight: bold;color:green">// Map again the hash of the message m</font>

byte[] hash = ... // Generate an hash from m (48-bit hash)
Element h = pairing.getG1().newElement().setFromHash(hash, 0, hash.length);

<font style="font-weight: bold;color:green">// Verify the signature</font>

Element temp1 = pairing.pairing(sig, g);
Element temp2 = pairing.pairing(h, pk);

if (temp1.isEqual(temp2))
    System.out.println("The signature is valid.");
else
    System.out.println("The signature is NOT valid.");
                </source>
            </subsection>
        </section>

        <a name="blsBCF"/>
        <section name="BLS under BouncyCastle">
            <p>
                You will find all the sources into the jpbc-crypto module.
            </p>

            <subsection name="Key Generation">
                <source>
import UTMAStrongParametersGenerator;
import UTMAStrongParameters;

<font style="font-weight: bold;color:green">// Init the generator.</font>
BLSParametersGenerator parametersGenerator = new BLSParametersGenerator();
parametersGenerator.init(curveParams);

<font style="font-weight: bold;color:green">// Generate the parameters.</font>
BLSParameters parameters = parametersGenerator.generateParameters();

<font style="font-weight: bold;color:green">// Store the parameters in a file.</font>
FileOutputStream fileOutputStream = new FileOutputStream("bls.params");

parametersGenerator.store(fileOutputStream, parameters);

fileOutputStream.flush();
fileOutputStream.close();
                </source>
            </subsection>

            <subsection name="Load the Public Information">
                <source>
import UTMAStrongParametersGenerator;
import UTMAStrongParameters;

<font style="font-weight: bold;color:green">// Init the generator.</font>
BLSParametersGenerator parametersGenerator = new BLSParametersGenerator();

<font style="font-weight: bold;color:green">// Load the parameters from a file.</font>
FileInputStream fileInputStream = new FileInputStream("utmas.params");

BLSParameters parameters = parametersGenerator.load(fileInputStream);

fileInputStream.close();
                </source>
            </subsection>

            <subsection name="Generate and Store a Key-Pair">
                <source>
import UTMAStrongKeyPairGenerator;
import UTMAStrongKeyGenerationParameters;
import org.bouncycastle.crypto.AsymmetricCipherKeyPair;

<font style="font-weight: bold;color:green">// Init the generator.</font>
BLSKeyPairGenerator keyPairGenerator = new BLSKeyPairGenerator();
keyPairGenerator.init(new BLSKeyGenerationParameters(null, parameters));

<font style="font-weight: bold;color:green">// Generate the key-pair.</font>
AsymmetricCipherKeyPair keyPair = keyPairGenerator.generateKeyPair();

<font style="font-weight: bold;color:green">// Store the key-pair.</font>
fileOutputStream = new FileOutputStream("bls_keypair.params");

keyPairGenerator.store(fileOutputStream, keyPair);

fileOutputStream.flush();
fileOutputStream.close();
                </source>
            </subsection>

            <subsection name="Load a Key-Pair">
                <source>
import UTMAStrongKeyPairGenerator;
import UTMAStrongKeyGenerationParameters;
import org.bouncycastle.crypto.AsymmetricCipherKeyPair;

<font style="font-weight: bold;color:green">// Init the generator.</font>
BLSKeyPairGenerator keyPairGenerator = new BLSKeyPairGenerator();

<font style="font-weight: bold;color:green">// Load the key-pair from a file.</font>
fileInputStream = new FileInputStream("bls_keypair.params");

AsymmetricCipherKeyPair keyPair = keyPairGenerator.load(fileInputStream);

fileInputStream.close();
                </source>
            </subsection>

            <subsection name="Signing">
                <source xml:space="preserve">
BLSSigner blsSigner = new BLSSigner(new SHA256Digest());

// Sign
blsSigner.init(true, keyPair.getPrivate());
blsSigner.update(message, 0, message.length);
byte[] sig = null;
try {
    sig = blsSigner.generateSignature();
} catch (CryptoException e) {
    fail(e.getMessage());
}
                </source>
            </subsection>

            <subsection name="Verification">
                <source>
blsSigner.init(false, keyPair.getPublic());
assertTrue(blsSigner.verifySignature(sig));
                </source>
            </subsection>
        </section>
    </body>
</document>
