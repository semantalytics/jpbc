<!DOCTYPE document PUBLIC
        "-//Apache Software Foundation//DTD XDOC 1.0//EN"
        "http://maven.apache.org/dtd/xdoc_1_0.dtd">
<document>
    <properties>
        <title>Java Pairing-Based Cryptography Library : Docs - Pairing Functions</title>
        <author email="decaro@dia.unisa.it">Angelo De Caro</author>
    </properties>

    <body>
        <section name="Pairing for Cryptography">

            <subsection name="Bilinear Setting">
                <p>
                    Let
                    <span lang="latex">\mathbb{G}_1</span>,
                    <span lang="latex">\mathbb{G}_2</span>
                    and
                    <span lang="latex">\mathbb{G}_T</span>
                    be cyclic groups of prime order
                    <span lang="latex">r</span>.
                    Let
                    <span lang="latex">g_1</span>
                    be a generator of
                    <span lang="latex">\mathbb{G}_1</span>
                    and
                    <span lang="latex">g_2</span>
                    be a generator of
                    <span lang="latex">\mathbb{G}_2</span>.
                    A
                    <strong>bilinear pairing</strong>
                    or
                    <strong>bilinear map</strong>
                    is an efficiently computable function
                    <span lang="latex">e : \mathbb{G}_1 \times \mathbb{G}_2 \leftarrow \mathbb{G}_T</span>
                    such that:
                </p>
                <ol>
                    <li>
                        <strong>Bilinearity</strong>: for all <span lang="latex">a,b\in\mathbb{Z}_r</span>
                        (the ring of integers modulo r)
                        it holds that
                        <span lang="latex">e(g_1^a,g_2^b) = e(g_1,g_2)^{ab}</span>
                    </li>
                    <li>
                        <strong>Non-degeneracy</strong>: <span lang="latex">e(g_1,g_2)\ne 1</span>.
                    </li>
                </ol>
                <p>
                    The tuple
                    <span lang="latex">(r,g_1,g_2,\mathbb{G}_1,\mathbb{G}_2,\mathbb{G}_T)</span>
                    is called
                    <strong>asymmetric bilinear setting</strong>.
                    If
                    <span lang="latex">\mathbb{G}_1=\mathbb{G}_2=\mathbb{G}</span>
                    and g is a generator of
                    <span lang="latex">\mathbb{G}</span>
                    then the tuple
                    <span lang="latex">\(r,g,\mathbb{G},\mathbb{G}_T)</span> is a
                    <strong>symmetric bilinear setting</strong>.
                    In the symmetric setting the order of
                    <span lang="latex">\mathbb{G}</span>
                    and
                    <span lang="latex">\mathbb{G}_T</span>
                    need not to be prime.
                </p>
                <p>
                    The cryptographic relevance of a bilinear mapping stems from the fact that in cyclic
                    groups that admit such a mapping the
                    <strong>Decisional Diffie-Hellman</strong>
                    assumption does not hold.
                    Indeed, given
                    <span lang="latex">(g,g^x,g^y,g^z)</span>
                    it is possible to check if
                    <span lang="latex">z=xy</span>
                    (and thus solve the Decisional DH problem) by testing
                    <span lang="latex">e(g,g^z)</span>
                    and
                    <span lang="latex">e(g^x,g^y)</span>
                    for equality.
                </p>
            </subsection>

            <subsection name="Multilinear Setting">
                <script type="text/javascript" src="http://latex.codecogs.com/latexit.js"/>

                An <span lang="latex">\ell</span>-group system consists of <span lang="latex">\ell</span>
                cyclic groups <span lang="latex">\mathbb{G}_1,\ldots,\mathbb{G}_\ell</span>
                of prime order <span lang="latex">p</span>, along with bilinear maps
                <span lang="latex">e_{i,j} : \mathbb{G}_i \times  \mathbb{G}_j \rightarrow \mathbb{G}_{i+j}</span>
                for all <span lang="latex">i,j\geq 1</span>
                with <span lang="latex">i+j\leq\ell</span>.
                Let <span lang="latex">g_i</span>
            </subsection>

            <a name="initializing"/>
            <subsection name="Initializing Pairings">
                <p>
                    The
                    <a href="../java-docs/api/it/unisa/dia/gas/jpbc/Pairing.html"><code>Pairing</code></a>
                    interface provides access to the algebraic structures underlying the pairing computation
                    and the pairing function.
                </p>

                <p>
                    The easiest way to obtain an instance of the
                    <a href="../java-docs/api/it/unisa/dia/gas/jpbc/Pairing.html"><code>Pairing</code></a>
                    interface is by using the factory provided by jPBC.
                    The factory takes in input the pairing parameters
                    and instantiates the appropriate classes.
                </p>

                <p>
                    To generate the pairing parameters look at this
                    <a href="./parametersgenerator.html">page</a>.
                </p>

                <p>
                    Let's now see a few examples of how to use the factory.
                </p>

                <ol>
                    <li>
                        <p>
                            Loading the paring parameters from a file.
                        </p>

                        <p>
                            Assume that the pairing parameters are stored in a file
                            called <code>params.properties</code>. Then
                            JPBC provides a Factory to create instances of the
                            <a href="../java-docs/api/it/unisa/dia/gas/jpbc/Pairing.html"><code>Pairing</code></a>
                            interface.
                        </p>
<source>import it.unisa.dia.gas.jpbc.*;
import it.unisa.dia.gas.plaf.jpbc.pairing.PairingFactory;

Pairing pairing = PairingFactory.getPairing("params.properties");
</source>
                    </li>
                    <li>
                        <p>
                            Generate on fly
                        </p>
<source>import it.unisa.dia.gas.jpbc.*;
import it.unisa.dia.gas.plaf.jpbc.pairing.PairingFactory;

// Enable the usage of the PBC wrapper when possible.
PairingFactory.getInstance().setUsePBCWhenPossible(true);

Pairing pairing = PairingFactory.getPairing("params.properties");
</source>
                    </li>
                    <p>
                        Notice that, if PBC and the jPBC wrapper are not installed properly then
                        the factory will use the jPBC classes instead for the pairing computation.
                        To know how to install the wrapper have a look
                        <a href="./pbcwrapper.html">here</a>.
                    </p>
                </ol>
            </subsection>

            <a name="accessing"/>
            <subsection name="Accessing Algebraic Structures">
            <p>
                The <a href="../java-docs/api/it/unisa/dia/gas/jpbc/Pairing.html"><code>Pairing</code></a>
                interface provides methods to access the algebraic structures
                involved in the pairing computation.
                Here are the methods:
            </p>

<source xml:space="preserve">/* Return Zr */
Field Zr = pairing.getZr();

/* Return G1 */
Field G1 = pairing.getG1();

/* Return G2 */
Field G2 = pairing.getG2();

/* Return GT */
Field GT = pairing.getGT();
</source>

                <p>
                These algebraic structures can be also accessed by index
                with the following mapping.
                </p>

<source xml:space="preserve">/* Return Zr */
Field Zr = pairing.getFieldAt(0);

/* Return G1 */
Field G1 = pairing.getFieldAt(1);

/* Return G2 */
Field G2 = pairing.getFieldAt(2);

/* Return GT */
Field GT = pairing.getFieldAt(3);
</source>
                <p>
                This is especially useful when dealing with multilinear maps
                to access the algebraic structures at different levels.
                <br/>
                The number of algebraic structures available is given by
                the degree of the pairing that can be obtained by invoking the following method.
                </p>

<source xml:space="preserve">int degree = pairing.getDegree();</source>

                <p>
                In particular, if <code>degree</code> is larger than two then there are
                <code>degree</code> algebraic structures available indexed from
                <code>0</code> to <code>degree-1</code>.
                The algebraic structure at level zero can be thought
                as the equivalent of <code>Zr</code>.
                <br/>
                Bilinear maps have degree two but in this case there are four
                algebraic structures available.
                </p>

                <p>
                Finally, elements of these algebraic structures can be initialized and manipulated
                for cryptographic operations as shown
                <a href="./field.html">here</a>.
                </p>
            </subsection>


            <a name="applying"/>
            <subsection name="Applying pairings">
                <p>
                    The <a href="../java-docs/api/it/unisa/dia/gas/jpbc/Pairing.html"><code>Pairing</code></a>
                    provides methods to apply the pairing function.

                    Given two elements <code>in1, in2</code>, belonging
                    to the appropriate algebraic structures, their pairing
                    can be computed by invoking the <code>pairing</code>
                    methods on input <code>in1</code> and <code>in2</code>
                    as follows:
                </p>
<source>Element out = pairing.pairing(in1, in2);</source>

                For symmetric bilinear settings, both inputs must lie in
                <code>G1</code>.
                For asymmetric bilinear settings, <code>in1</code>
                must be in <code>G1</code> and <code>in2</code>
                in <code>G2</code>.

                <br/>
                For multilinear settings of degree <code>degree</code>,
                let <code>in1</code> be in <code>Gi</code> and
                <code>in2</code> be in <code>Gj</code>,
                with <code>i,j</code> in <code>[1..degree]</code>,
                it must hold that <code>i+j &lt; degree</code>.


                <p>
                    Furthermore, you can compute the product of pairings in one shot using
                    the following code:
                </p>
<source xml:space="preserve">
Element in1[] = new Element[5];
for (int i = 0; i &lt; 5; i++)
in1[i] = pairing.get<code>G1</code>().newRandomElement();

Element in2[] = new Element[5];
for (int i = 0; i &lt; 5; i++)
in2[i] = pairing.get<code>G2</code>().newRandomElement();

Element out = pairing.pairing(in1, in2);
</source>
            </subsection>

            <a name="preprocessing"/>
            <subsection name="Preprocessing">
                <p>
                    If it is known in advance that a particular value (in <code>G1</code>)
                    will be paired several times
                    then time can be saved in the
                    long run by using preprocessing.
                </p>

<source xml:space="preserve">
/* Get ready to perform a pairing whose first input is in1,
store the results of time-saving precomputation in ppp. */

Element in1 = pairing.get<code>G1</code>().newRandomElement();
PairingPreProcessing ppp = pairing.pairing(in1);

/* Compute the pairing using in2 and the preprocessed information
stored in ppp. The inputs to the pairing are the element
previously used to initialize ppp and the element in2. */

Element in2 = pairing.get<code>G2</code>().newRandomElement();
Element out = ppp.pairing(in2);
</source>

                <p>
                    The result of the precomputation can be stored to be used later.
                    The following code convert
                    <code>ppp</code>
                    to a byte array:
                </p>
<source xml:space="preserve">
byte[] pppBytes = ppp.toBytes();
</source>
                <p>
                    To convert the byte array to an instance of the PairingPreProcessing interface
                    use the following code:
                </p>
<source xml:space="preserve">
PairingPreProcessing ppp = pairing.pairing(pppBytes);
</source>
            </subsection>
        </section>
    </body>
</document>
