<!DOCTYPE document PUBLIC
        "-//Apache Software Foundation//DTD XDOC 1.0//EN"
        "http://maven.apache.org/dtd/xdoc_1_0.dtd">
<document>
    <properties>
        <title>jPBC : Docs - Element Functions</title>
        <author email="decaro@dia.unisa.it">Angelo De Caro</author>
    </properties>

    <body>
        <section name="Element Functions">
            <p>
                Elements of groups, rings and fields are accessible using the
                <a href="../java-docs/api/it/unisa/dia/gas/jpbc/Element.html">
                    <code>
                        <strong style="color:red">it.unisa.dia.gas.jpbc.Element</strong>
                    </code>
                </a>

                interface which represents a mutable value. So any method you call on it affect the element's value.
            </p>

            <a name="initializing"/>
            <subsection name="Initializing Elements">
                <p>
                    You can obtain an instance of an Element starting from an algebraic structure, such as a particular
                    finite field or elliptic curve group. Go
                    <a href="./field.html">here</a>
                    to know how.
                </p>
            </subsection>

            <a name="assigning"/>
            <subsection name="Assigning Elements">
                <p>
                    The following methods can be used to assign values to elements. When integers are assigned,
                    they are mapped to algebraic structures canonically if it makes sense (e.g. rings and fields).
                </p>

                <source>/* Sets an element to zero. */
<strong style="color:green">element.setToZero();</strong>
                </source>

                <source>/* Sets an element to one. */
<strong style="color:green">element.setToOne();</strong>
                </source>

                <source>/* If the element lies in a finite algebraic structure, assigns a uniformly random element to it. */
<strong style="color:green">element.setToRandom();</strong>
                </source>

                <source>/* Sets the element to an int. */
<strong style="color:green">element.set(5);</strong>
                </source>

                <source>/* Sets the element to a BigInteger. */
<strong style="color:green">element.set(new BigInteger("126785438"));</strong>
                </source>

            </subsection>

            <a name="arithmetic"/>
            <subsection name="Element Arithmetic">
                The addition and the multiplication functions perform addition and multiplication operations in rings and
                fields. For groups of points on an elliptic curve, such as the G1 and G2 groups associated with
                pairings, both addition and multiplication represent the group operation (and similarly both
                <code>0</code>
                and
                <code>1</code>
                represent the identity element).

                In contrast, the GT group is currently implemented as a subgroup of a finite field, so only
                multiplicative operations should be used for GT.

                <source>/* Performs the addition between element and a.*/
Element a = element.getField().newElement(5);
<strong style="color:green">element.add(a);</strong>
                </source>

                <source>/* Performs the substraction between element and a.
Element a = element.getField().newElement(5);
<strong style="color:green">element.sub(a);</strong>
                </source>

                <source>/* Performs the multiplication between element and a. */
Element a = element.getField().newElement(5);
<strong style="color:green">element.mul(a);</strong>
                </source>

                <source>/* Performs the multiplication between element and an int. */
<strong style="color:green">element.mul(5);</strong>
                </source>

                <source>/* Performs the multiplication between element and a BigInteger. */
<strong style="color:green">element.mul(new BigInteger("5"));</strong>
                </source>

                <source>/* Performs the multiplication between element and z where z must be an element of a integer mod ring (i.e. Zn for some n). */
Element z = pairing.getZr().newRandomElement();
<strong style="color:green">element.mulZn(z);</strong>
                </source>
            </subsection>

            <a name="exponentiating"/>
            <subsection name="Exponentiating Elements">
                <source>
/* Raises element to a BigInteger. */
<strong style="color:green">element.pow(BigInteger.valueOf(5));</strong>
                </source>

                <source>
/* Raises element to a z which must be an element of a integer mod ring (i.e. Zn for some n). */
Element z = pairing.getZr().newRandomElement();
<strong style="color:green">element.mulZn(z);</strong>
                </source>

                <p>
                    There is another way to exponentiate an element which uses a pre-processing technique. So if you have
                    for many times the same base you can use the following code to reduce the time used to compute
                    the power.
                    <br/>
                    The interface to be used is
                    <code><strong style="color:red">it.unisa.dia.gas.jpbc.ElementPowPreProcessing</strong></code>
                </p>

                <source xml:space="preserve">/* Prepare element to be raised and store pre-processing information in ppp.
element will be not modified in any way.*/

<strong style="color:green">ElementPowPreProcessing ppp = element.pow();</strong>

/* Now let's raise using ppp which returns a new element which contains the result of the operation. */

Element out = <strong style="color:green">ppp.pow(BigInteger.valueOf(5));</strong>

out = <strong style="color:green">ppp.pow(pairing.getZr().newRandomElement());</strong>
                </source>

            </subsection>
            
            <a name="comparing"/>
            <subsection name="Comparing Elements">
                                
                <source>/* Returns true if the element is 1. */
<strong style="color:green">element.isOne();</strong>
                </source>

                <source>/* Returns true if the element is 0. */
<strong style="color:green">element.isZero();</strong>
                </source>

                <source>/* Returns 0 if a and b are the same, nonzero otherwise. */
<strong style="color:green">a.compareTo(b);</strong>
                </source>

                <source>/* Returns true if this element is a perfect square (quadratic residue), false otherwise. */
<strong style="color:green">element.isSqr();</strong>
                </source>

                <source>/* If this element is zero, returns 0. For a non zero value the behaviour depends on the algebraic structure. */
<strong style="color:green">element.sign();</strong>
                </source>
            </subsection>

            <a name="io"/>
            <subsection name="Import/Export Elements">

                <source>/* Converts element to bytes. The number of bytes it will write can be determined
calling getLengthInBytes(). */
<strong style="color:green">byte[] bytes = element.toBytes();</strong>
                </source>

                <source>/* Reads element from the buffer source and returns the number of bytes read. */
<strong style="color:green">element.setFromBytes(bytes);</strong>
                </source>

                <source>/* Reads element from the buffer source, starting from the passed offset,
and returns the number of bytes read. */
<strong style="color:green">element.setFromBytes(bytes, 13);</strong>
                </source>

                <source>/* Sets element deterministically from the buffer source.*/
<strong style="color:green">element.setFromHash(bytes, 0, bytes.length);</strong>
                </source>

                <source>/* Encodes the buffer source into element. */
<strong style="color:green">element.setEncoding(bytes);</strong>
                </source>

                <source>/* Returns the bytes encoded by element. */
<strong style="color:green">byte[] bytes = element.getDecoding();</strong>
                </source>
            </subsection>
        </section>
    </body>
</document>
